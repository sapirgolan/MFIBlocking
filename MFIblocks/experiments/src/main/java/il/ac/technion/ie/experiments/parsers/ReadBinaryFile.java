package il.ac.technion.ie.experiments.parsers;

import org.apache.commons.io.EndianUtils;
import org.apache.log4j.Logger;

import java.io.*;
import java.util.Map;
import java.util.TreeMap;

/**
 * Created by I062070 on 03/09/2015.
 */
public class ReadBinaryFile {

    private static final Logger logger = Logger.getLogger(ReadBinaryFile.class);

    public Map<Integer, Double> readFile(String filePath) throws FileNotFoundException {
        return this.readFile(new File(filePath));
    }

    /**
     * Parse a Binary file that was generated by ConvexBP algorithm. See {@link il.ac.technion.ie.experiments.threads.CommandExacter}
     * for more information how to invoke ConvexBP algorithm.
     * <p/>
     * The returned value is a {@link java.util.Map} that is sorted by its keys.
     * The Key is a line index in the Binary file and the Value is a probability that was found in that line.
     * <p/>
     * Those probabilities should be applied to the blocks that were the subject of ConvexBP.
     * <p>
     * if the input in the UAI file was '3 2 4', then values who corresponds to keys 1-3 are the probabilities of records in the first block.
     * values who corresponds to keys 4-5 are the probabilities of records in the second block.
     * values who corresponds to keys 6-9 are the probabilities of records in the third block
     * </p>
     *
     * @param binaryFile - file that was generated by execution of ConvexBP algorithm.
     * @return A map of probabilities mapped by row Index.
     * @throws FileNotFoundException
     */
    public Map<Integer, Double> readFile(File binaryFile) throws FileNotFoundException {
        assertOnFile(binaryFile);
        DataInputStream dataIn = getDataInputStream(binaryFile);
        TreeMap<Integer, Double> lineNumberToProbabilityMap = new TreeMap<>();
        try {
            int index = 1;
            while (true) {
                try {
                    lineNumberToProbabilityMap.put(index, convertBinaryDataToNumber(dataIn));
                    index++;
                } catch (EOFException e) {
                    logger.debug("Finished reading file");
                    break;
                }
            }
        } catch (IOException e) {
            logger.error("Failed to read binary file", e);
        }
        return lineNumberToProbabilityMap;
    }

    private double convertBinaryDataToNumber(DataInputStream dataIn) throws IOException {
        return EndianUtils.readSwappedDouble(dataIn);
    }

    private DataInputStream getDataInputStream(File binaryFile) throws FileNotFoundException {
        return new DataInputStream(
                new BufferedInputStream(
                        new FileInputStream(binaryFile)));
    }

    private void assertOnFile(File binaryFile) throws FileNotFoundException {
        if (binaryFile == null) {
            logger.error("Failed to verify binary file - it is null");
            throw new FileNotFoundException("binary file doesn't exists");
        }
        if (!binaryFile.exists() || !binaryFile.canRead()) {
            logger.error("Failed to verify binary file - it does not exists");
            throw new FileNotFoundException("binary file doesn't exists at: " + binaryFile.getAbsolutePath());
        }
    }
}
